<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Sandbox</title>
    <style>
      body { margin: 0; background: black; overflow: hidden; }
      canvas { display: block; margin: auto; }
    </style>
</head>
<body>
<canvas width="512" height="512"></canvas>
<script type="module">
	const GRID_SIZE = 64;
	const WORKGROUP_SIZE = 8;

	const canvas = document.querySelector("canvas");
	const adapter = await navigator.gpu.requestAdapter();
	const device = await adapter.requestDevice();
	const context = canvas.getContext("webgpu");
	const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
	context.configure({ device, format: canvasFormat });

	let isMouseDown = false;
      const spawnQueue = [];

      canvas.addEventListener("mousedown", () => { isMouseDown = true; });
	  canvas.addEventListener("mouseup", () => { isMouseDown = false; });
	  canvas.addEventListener("mouseleave", () => { isMouseDown = false; });
      canvas.addEventListener("mousemove", (event) => {
      	if (!isMouseDown) return;

		const rect = canvas.getBoundingClientRect();
		const mouseX = event.clientX - rect.left;
		const mouseY = event.clientY - rect.top;

		const gridX = Math.floor(mouseX / canvas.width * GRID_SIZE);
		const gridY = Math.floor((canvas.height - mouseY) / canvas.height * GRID_SIZE);

		spawnQueue.push([gridX, gridY]);
	});

	const vertices = new Float32Array([
	  -1.0, -1.0,
	   1.0, -1.0,
	   1.0,  1.0,
	  -1.0, -1.0,
	   1.0,  1.0,
	  -1.0,  1.0,
	]);

	const vertexBuffer = device.createBuffer({
	  size: vertices.byteLength,
	  usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
	});
	device.queue.writeBuffer(vertexBuffer, 0, vertices);

	const vertexBufferLayout = {
	  arrayStride: 8,
	  attributes: [{
	    format: "float32x2",
	    offset: 0,
	    shaderLocation: 0,
	  }],
	};

	const uniformBuffer = device.createBuffer({
	  size: 8,
	  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
	});
	device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([GRID_SIZE, GRID_SIZE]));

	const cellState = new Uint32Array(GRID_SIZE * GRID_SIZE);
	const cellStateBuffer = device.createBuffer({
	  size: cellState.byteLength,
	  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
	});

	// Fill initial state
	for (let i = 0; i < cellState.length; i++) {
	  cellState[i] = Math.random() < 0.1 ? 1 : 0;
	}
	device.queue.writeBuffer(cellStateBuffer, 0, cellState);

	const shaderModule = device.createShaderModule({
	  code: `
	  struct VertexInput {
	    @location(0) pos: vec2f,
	    @builtin(instance_index) instance: u32,
	  };
	  
	  struct VertexOutput {
	    @builtin(position) pos: vec4f,
	    @location(0) cell: vec2f,
	  };

	  @group(0) @binding(0) var<uniform> grid: vec2f;
	  @group(0) @binding(1) var<storage> cellState: array<u32>;

	  @vertex
	  fn vertexMain(input: VertexInput) -> VertexOutput {
	    let i = f32(input.instance);
	    let cell = vec2f(i % grid.x, floor(i / grid.x));
	    let state = f32(cellState[input.instance]);

	    let cellOffset = cell / grid * 2.0;
	    let gridPos = (input.pos * state + 1.0) / grid - 1.0 + cellOffset;

	    var out: VertexOutput;
	    out.pos = vec4f(gridPos, 0, 1);
	    out.cell = cell;
	    return out;
	  }

	  @fragment
	  fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
	    return vec4f(input.cell / grid, 1.0 - (input.cell.x + input.cell.y) / (grid.x + grid.y), 1);
	  }
	  `
	});

	const bindGroupLayout = device.createBindGroupLayout({
	  entries: [
	    { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: {} },
	    { binding: 1, visibility: GPUShaderStage.VERTEX, buffer: { type: "read-only-storage" } },
	  ]
	});

	const bindGroup = device.createBindGroup({
	  layout: bindGroupLayout,
	  entries: [
	    { binding: 0, resource: { buffer: uniformBuffer } },
	    { binding: 1, resource: { buffer: cellStateBuffer } },
	  ]
	});

	const pipeline = device.createRenderPipeline({
	  layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
	  vertex: {
	    module: shaderModule,
	    entryPoint: "vertexMain",
	    buffers: [vertexBufferLayout],
	  },
	  fragment: {
	    module: shaderModule,
	    entryPoint: "fragmentMain",
	    targets: [{ format: canvasFormat }],
	  },
	  primitive: { topology: "triangle-list" },
	});

	function updateSimulation() {
		for (const [x, y] of spawnQueue) {
		  if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
		  const index = y * GRID_SIZE + x;
		  cellState[index] = 1;
		}
		spawnQueue.length = 0;

	  const newState = cellState.slice();

	  for (let y = 1; y < GRID_SIZE; y++) {
	    for (let x = 0; x < GRID_SIZE; x++) {
	      const i = y * GRID_SIZE + x;
	      if (cellState[i] === 1) {
	        const below = (y - 1) * GRID_SIZE + x;

	        if (cellState[below] === 0) {
	          newState[i] = 0;
	          newState[below] = 1;
	        } else {
	          const leftBelow = (x > 0) ? below - 1 : -1;
	          const rightBelow = (x < GRID_SIZE - 1) ? below + 1 : -1;

	          if (leftBelow >= 0 && cellState[leftBelow] === 0) {
	            newState[i] = 0;
	            newState[leftBelow] = 1;
	          } else if (rightBelow >= 0 && cellState[rightBelow] === 0) {
	            newState[i] = 0;
	            newState[rightBelow] = 1;
	          }
	        }
	      }
	    }
	  }
	  cellState.set(newState);
	}

	function frame() {
	  updateSimulation();
	  device.queue.writeBuffer(cellStateBuffer, 0, cellState);

	  const encoder = device.createCommandEncoder();
	  const pass = encoder.beginRenderPass({
	    colorAttachments: [{
	      view: context.getCurrentTexture().createView(),
	      loadOp: "clear",
	      storeOp: "store",
	      clearValue: { r: 0, g: 0, b: 0.2, a: 1 },
	    }]
	  });

	  pass.setPipeline(pipeline);
	  pass.setVertexBuffer(0, vertexBuffer);
	  pass.setBindGroup(0, bindGroup);
	  pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE);
	  pass.end();
	  device.queue.submit([encoder.finish()]);

	  requestAnimationFrame(frame);
	}

	requestAnimationFrame(frame);
</script>
</body>
</html>
