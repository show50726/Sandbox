<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Sandbox</title>
    <style>
        body {
            background-color: #111;
            color: #eee;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
        }
        #ui-container {
            padding: 10px;
            display: flex;
            gap: 20px;
            align-items: center;
            background-color: #333;
            width: 512px;
            box-sizing: border-box;
            border-radius: 8px 8px 0 0;
        }
        #controls button {
            padding: 6px 12px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background: #555;
            color: #eee;
            cursor: pointer;
        }
        #controls button.active {
            background: #007bff;
            border-color: #007bff;
            font-weight: bold;
        }
        #fps {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 4px 8px;
            border-radius: 4px;
        }
        canvas {
            background-color: #000;
            border-radius: 0 0 8px 8px;
        }
    </style>
</head>
<body>

<div id="ui-container">
    <div id="fps">FPS: 0</div>
    <div id="controls">
        <button id="sandButton" class="active">Sand</button>
        <button id="waterButton">Water</button>
        <button id="stoneButton">Stone</button>
    </div>
</div>

<canvas width="512" height="512"></canvas>
<script type="module">
    const GRID_SIZE = 128;
    const SAND_INDEX = 1;
    const WATER_INDEX = 2;
    const STONE_INDEX = 3;

    const fpsDisplay = document.getElementById("fps");
    let lastTime = performance.now();
    let frames = 0;
    let fps = 0;

    const canvas = document.querySelector("canvas");
    const adapter = await navigator.gpu.requestAdapter();
    const device = await adapter.requestDevice();
    const context = canvas.getContext("webgpu");
    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
    context.configure({device, format: canvasFormat});

    const sandButton = document.getElementById("sandButton");
    const waterButton = document.getElementById("waterButton");
    const stoneButton = document.getElementById("stoneButton");

    let currentParticleType = SAND_INDEX;
    sandButton.addEventListener("click", () => {
        currentParticleType = SAND_INDEX;
        sandButton.classList.add("active");
        waterButton.classList.remove("active");
        stoneButton.classList.remove("active");
    });

    waterButton.addEventListener("click", () => {
        currentParticleType = WATER_INDEX;
        waterButton.classList.add("active");
        sandButton.classList.remove("active");
        stoneButton.classList.remove("active");
    });

    stoneButton.addEventListener("click", () => {
        currentParticleType = STONE_INDEX;
        waterButton.classList.remove("active");
        sandButton.classList.remove("active");
        stoneButton.classList.add("active");
    });

    let isMouseDown = false;
    const spawnQueue = [];

    canvas.addEventListener("mousedown", () => {
        isMouseDown = true;
    });
    canvas.addEventListener("mouseup", () => {
        isMouseDown = false;
    });
    canvas.addEventListener("mouseleave", () => {
        isMouseDown = false;
    });
    canvas.addEventListener("mousemove", (event) => {
        if (!isMouseDown) return;

        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        const gridX = Math.floor(mouseX / canvas.width * GRID_SIZE);
        const gridY = Math.floor((canvas.height - mouseY) / canvas.height * GRID_SIZE);

        spawnQueue.push([gridX, gridY, currentParticleType]);
    });

    const vertices = new Float32Array([
        -1.0, -1.0,
        1.0, -1.0,
        1.0, 1.0,
        -1.0, -1.0,
        1.0, 1.0,
        -1.0, 1.0,
    ]);

    const vertexBuffer = device.createBuffer({
        size: vertices.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    });
    device.queue.writeBuffer(vertexBuffer, 0, vertices);

    const vertexBufferLayout = {
        arrayStride: 8,
        attributes: [{
            format: "float32x2",
            offset: 0,
            shaderLocation: 0,
        }],
    };

    const uniformBuffer = device.createBuffer({
        size: 8,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([GRID_SIZE, GRID_SIZE]));

    const cellState = new Uint32Array(GRID_SIZE * GRID_SIZE);
    const cellStateBuffer = device.createBuffer({
        size: cellState.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });

    // Fill initial state
    for (let i = 0; i < cellState.length; i++) {
        cellState[i] = Math.random() < 0.1 ? 1 : 0;
    }
    device.queue.writeBuffer(cellStateBuffer, 0, cellState);

    const shaderModule = device.createShaderModule({
        code: `
	  struct VertexInput {
	    @location(0) pos: vec2f,
	    @builtin(instance_index) instance: u32,
	  };

	  struct VertexOutput {
	    @builtin(position) pos: vec4f,
	    @location(0) cell: vec2f,
	    @location(1) color: vec3f,
	  };

	  @group(0) @binding(0) var<uniform> grid: vec2f;
	  @group(0) @binding(1) var<storage> cellState: array<u32>;

	  @vertex
	  fn vertexMain(input: VertexInput) -> VertexOutput {
	    let i = f32(input.instance);
	    let cell = vec2f(i % grid.x, floor(i / grid.x));
	    let state = f32(cellState[input.instance]);

	    let cellOffset = cell / grid * 2.0;
	    let scale = saturate(state);
	    let gridPos = (input.pos * scale + 1.0) / grid - 1.0 + cellOffset;

        var color = vec3f(0.8, 0.6, 0.2);
        if(state==${WATER_INDEX}f){
            color = vec3f(0.2, 0.5, 0.8);
        }
        if(state==${STONE_INDEX}f){
            color = vec3f(0.8, 0.8, 0.8);
        }

	    var out: VertexOutput;
	    out.pos = vec4f(gridPos, 0, 1);
	    out.cell = cell;
	    out.color = color;
	    return out;
	  }

	  @fragment
	  fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
	    return vec4f(input.color, 1);
	  }
	  `
    });

    const bindGroupLayout = device.createBindGroupLayout({
        entries: [
            {binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: {}},
            {binding: 1, visibility: GPUShaderStage.VERTEX, buffer: {type: "read-only-storage"}},
        ]
    });

    const bindGroup = device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
            {binding: 0, resource: {buffer: uniformBuffer}},
            {binding: 1, resource: {buffer: cellStateBuffer}},
        ]
    });

    const pipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({bindGroupLayouts: [bindGroupLayout]}),
        vertex: {
            module: shaderModule,
            entryPoint: "vertexMain",
            buffers: [vertexBufferLayout],
        },
        fragment: {
            module: shaderModule,
            entryPoint: "fragmentMain",
            targets: [{format: canvasFormat}],
        },
        primitive: {topology: "triangle-list"},
    });

    function updateSimulation() {
        for (const [x, y, p_type] of spawnQueue) {
            if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
            const index = y * GRID_SIZE + x;
            cellState[index] = p_type;
        }
        spawnQueue.length = 0;

        const newState = cellState.slice();

        for (let y = GRID_SIZE - 1; y > 0; y--) {
            for (let x = 0; x < GRID_SIZE; x++) {
                const index = y * GRID_SIZE + x;
                if (cellState[index] === SAND_INDEX) {
                    let directions = [[0, -1], [-1, -1], [1, -1]];
                    let moved = false;
                    for (const dir of directions) {
                        let newX = x + dir[0];
                        let newY = y + dir[1];

                        if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                            let newIndex = newY * GRID_SIZE + newX;
                            if (newState[newIndex] === 0 || newState[newIndex] === 2) {
                                newState[newIndex] = SAND_INDEX;
                                newState[index] = cellState[newIndex];
                                moved = true;
                                break;
                            }
                        }
                    }
                }
                else if(cellState[index] === WATER_INDEX) {
                    let directions = [[0, -1], [-1, -1], [1, -1], [-1, 0], [1, 0]];

                    let moved = false;
                    for (const dir of directions) {
                        let newX = x + dir[0];
                        let newY = y + dir[1];

                        if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                            let newIndex = newY * GRID_SIZE + newX;
                            if (newState[newIndex] === 0) {
                                newState[newIndex] = WATER_INDEX;
                                newState[index] = 0;
                                moved = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        cellState.set(newState);
    }

    function frame() {
        const now = performance.now();
        const delta = now - lastTime;
        frames++;

        if (delta >= 1000) {
            fps = frames * 1000 / delta;
            fpsDisplay.textContent = `FPS: ${fps.toFixed(1)}`;
            frames = 0;
            lastTime = now;
        }

        updateSimulation();
        device.queue.writeBuffer(cellStateBuffer, 0, cellState);

        const encoder = device.createCommandEncoder();
        const pass = encoder.beginRenderPass({
            colorAttachments: [{
                view: context.getCurrentTexture().createView(),
                loadOp: "clear",
                storeOp: "store",
                clearValue: {r: 0, g: 0, b: 0.2, a: 1},
            }]
        });

        pass.setPipeline(pipeline);
        pass.setVertexBuffer(0, vertexBuffer);
        pass.setBindGroup(0, bindGroup);
        pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE);
        pass.end();
        device.queue.submit([encoder.finish()]);

        requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
</script>
</body>
</html>
